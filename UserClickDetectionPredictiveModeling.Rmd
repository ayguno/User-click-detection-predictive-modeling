---
title: "Feature Engineering for user click detection predictive modeling"
author: "Ozan Aygun"
date: "12/15/2017"
output: 
   html_document:
        toc: true
        number_sections: true
        depth: 4
        theme: cerulean
        highlight: tango
        df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(results = "markup", fig.align = "center",
                      fig.width = 6, fig.height = 5,message=FALSE,warning=FALSE)
```

# Introduction and summary

# Loading and developing expectations from data

We will start working with the small subset of the training data that contain 100.000 observations just to develops some expectations from the data. The actual training set contains ~ 200 milion observations, we will attempt to download and process it once we locked down our processing and feature engineering pipeline.

```{r, cache=TRUE}
train_sample <- read.csv("train_sample.csv", stringsAsFactors = F)
```

```{r}
str(train_sample)
```
```{r}
apply(train_sample,2,function(x){sum(is.na(x))})
```
```{r}
summary(train_sample)
```

```{r}
apply(train_sample,2, function(x){return(length(unique(x)))})
```

```{r}
table(train_sample$is_attributed)
```

# Data processing and Feature Engineering Pipeline

We will start writing our pipeline function as we continue developing expectations from the sample data set we have.

## Understanding relationship between clicks and IPs

Are the clicks distributed randomly amongst the different IPs? 

YES. Most likely at the end we can remove this feature.

```{r}
library(ggplot2)
ggplot(train_sample,aes(ip,is_attributed,col = factor(is_attributed)))+
        scale_color_manual(values = c("red","navy"))+
        geom_point()
        
```

## Understanding the relationship between clicks and Device type

```{r}
library(ggplot2)
ggplot(train_sample,aes(device,is_attributed,col = factor(is_attributed), alpha(0.2)))+
        scale_color_manual(values = c("red","navy"))+
        geom_point()
        
```

It looks like certain devices are more likely to be used in true events:

```{r}
length(unique(train_sample$device[train_sample$is_attributed == 1]))
```

Therefore, these 25 devices are more likely to be used in true events. We will encode device as a dummy variable:

```{r}
# Creating our processing pipeline
processing_pipeline <- function(dataset){
        require(caret)
        require(dplyr)
        # Convert device to dummy variable
        dataset$device <- as.factor(dataset$device)
        device_dummy <- dummyVars(is_attributed ~ device, dataset)
        dataset <- cbind(dataset,predict(device_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -device)
        
        return(dataset)
}
```

Test the current pipeline on training sample:

```{r, eval= FALSE}
processed_train_sample <- processing_pipeline(train_sample)
```

The pipeline converts device to dummy variable.

## Understanding the relationship between clicks and app type

```{r}
library(ggplot2)
ggplot(train_sample,aes(app,is_attributed,col = factor(is_attributed), alpha(0.2)))+
        scale_color_manual(values = c("red","navy"))+
        geom_point()
        
```

Some apps may be more likely to be downloaded. Convert app into dummy variable by adding this step into our pipeline:

```{r}
# Update our processing pipeline
processing_pipeline <- function(dataset){
        require(caret)
        require(dplyr)
        
        # Convert device to dummy variable
        dataset$device <- as.factor(dataset$device)
        device_dummy <- dummyVars(is_attributed ~ device, dataset)
        dataset <- cbind(dataset,predict(device_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -device)
        
        # Convert app to dummy variable
        dataset$app <- as.factor(dataset$app)
        app_dummy <- dummyVars(is_attributed ~ app, dataset)
        dataset <- cbind(dataset,predict(app_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -app)
        
        
        return(dataset)
}
```

Test the current pipeline on training sample:

```{r, eval= FALSE}
# It works!
processed_train_sample <- processing_pipeline(train_sample)
```

## Understanding the relationship between clicks and os type

```{r}
library(ggplot2)
ggplot(train_sample,aes(os,is_attributed,col = factor(is_attributed), alpha(0.2)))+
        scale_color_manual(values = c("red","navy"))+
        geom_point()
        
```

We will add os dummy variable by updating our pipeline:

```{r}
# Update our processing pipeline
processing_pipeline <- function(dataset){
        require(caret)
        require(dplyr)
        
        # Convert device to dummy variable
        dataset$device <- as.factor(dataset$device)
        device_dummy <- dummyVars(is_attributed ~ device, dataset)
        dataset <- cbind(dataset,predict(device_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -device)
        
        # Convert app to dummy variable
        dataset$app <- as.factor(dataset$app)
        app_dummy <- dummyVars(is_attributed ~ app, dataset)
        dataset <- cbind(dataset,predict(app_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -app)
        
        # Convert os to dummy variable
        dataset$os <- as.factor(dataset$os)
        os_dummy <- dummyVars(is_attributed ~ os, dataset)
        dataset <- cbind(dataset,predict(os_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -os)
        
        return(dataset)
}
```

Test the current pipeline on training sample:

```{r, eval= FALSE}
# It works!
processed_train_sample <- processing_pipeline(train_sample)
```

## Understanding the relationship between clicks and channel type

```{r}
library(ggplot2)
ggplot(train_sample,aes(channel,is_attributed,col = factor(is_attributed), alpha(0.2)))+
        scale_color_manual(values = c("red","navy"))+
        geom_point()
        
```

This rather looks random, but not as much as the IPs. My intuition says that this could be a partiallly relevant feature, so will convert it to dummy variable:

```{r}
# Update our processing pipeline
processing_pipeline <- function(dataset){
        require(caret)
        require(dplyr)
        
        # Convert device to dummy variable
        dataset$device <- as.factor(dataset$device)
        device_dummy <- dummyVars(is_attributed ~ device, dataset)
        dataset <- cbind(dataset,predict(device_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -device)
        
        # Convert app to dummy variable
        dataset$app <- as.factor(dataset$app)
        app_dummy <- dummyVars(is_attributed ~ app, dataset)
        dataset <- cbind(dataset,predict(app_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -app)
        
        # Convert os to dummy variable
        dataset$os <- as.factor(dataset$os)
        os_dummy <- dummyVars(is_attributed ~ os, dataset)
        dataset <- cbind(dataset,predict(os_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -os)
        
        # Convert channel to dummy variable
        dataset$channel <- as.factor(dataset$channel)
        channel_dummy <- dummyVars(is_attributed ~ channel, dataset)
        dataset <- cbind(dataset,predict(channel_dummy, newdata = dataset))
        dataset <- dplyr::select(dataset, -channel)
        
        return(dataset)
}
```

Test the current pipeline on training sample:

```{r, eval= FALSE}
# It works!
processed_train_sample <- processing_pipeline(train_sample)
```

